<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>United States Food Establishment Inspection, Mapped</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #map {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        .side-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: white;
            opacity: 0.9;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            transition: right 0.3s ease-in-out;
            z-index: 1000;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }

        .side-panel.open {
            right: 0;
        }

        .panel-header {
            background: #007cba;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1001;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-content {
            padding: 20px;
        }

        .toggle-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #535353;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Gotham Bold', 'Gotham', 'Helvetica Neue', Arial, sans-serif;
            opacity: 0.7;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 999;
            transition: background-color 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .toggle-btn:hover {
            background-color: #666666;
        }

        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            font-weight: bold;
            color: #333;
            font-size: 12px;
            margin-bottom: 5px;
        }

        select, input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .legend {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .legend h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .stats {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .stats h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px solid #ddd;
        }

        .stat-label {
            font-weight: bold;
        }

        .risk-high { color: #d32f2f; }
        .risk-medium { color: #f57c00; }
        .risk-low { color: #388e3c; }

        .status-info {
            background: #e3f2fd;
            color: #1976d2;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 12px;
            text-align: center;
        }

        #refreshBtn {
            width: 100%;
            background: #007cba;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #refreshBtn:hover:not(:disabled) {
            background-color: #005a87;
        }

        #refreshBtn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .loading, .error {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            border-radius: 6px;
            z-index: 999;
            font-weight: bold;
        }

        .loading {
            background: #e3f2fd;
            color: #1976d2;
        }

        .error {
            background: #ffebee;
            color: #c62828;
        }

        /* Progress bar - marker loading */
        .progress-container {
            position: fixed;
            top: 20px;
            left: 170px;
            transform: translateX(-50%);
            background: white;
            opacity: 0.65;
            backdrop-filter: blur(5px);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 999;
            min-width: 300px;
            display: none;
        }

        .progress-text {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        .progress-bar-container {
            background: #e0e0e0;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(90deg, #007cba, #005a87);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .progress-stats {
            margin-top: 8px;
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .leaflet-interactive {
            transition: opacity 0.3s ease-in-out, fill-opacity 0.3s ease-in-out !important;
        }

        .city-title {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 15px;
            border-radius: 6px;
            z-index: 999;
            font-size: 64px;
            font-family: 'Gotham Bold', 'Gotham', 'Helvetica Neue', Arial, sans-serif;
            font-weight: bold;
            opacity: 0.8;
            color: #424242;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .city-title:hover {
            opacity: 1;
            transform: scale(1.02);
        }

        .city-subtitle {
            position: fixed;
            bottom: 100px;
            left: 25px;
            padding: 0px 15px;
            z-index: 999;
            font-size: 12px;
            font-family: 'Gotham', 'Helvetica Neue', Arial, sans-serif;
            font-weight: bold;
            opacity: 0.5;
            color: #424242;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            transition: letter-spacing 0.3s ease;
        }

        .leaflet-popup-content-wrapper {
            background: transparent !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15) !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        .leaflet-popup-content {
            margin: 0 !important;
            padding: 0 !important;
            background: transparent !important;
            border-radius: 8px !important;
            overflow: hidden !important;
        }

        .leaflet-popup-tip {
            background: #007cba !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
        }

        .leaflet-popup-close-button {
            color: white !important;
            font-weight: normal !important;
            font-size: 18px !important;
        }

        /* City selector */
        .city-selector {
            position: fixed;
            bottom: 40px;
            right: 20px;
            z-index: 999;
            background: rgba(66, 66, 66, 0.12);
            border-radius: 25px;
            padding: 5px;
            display: flex;
            gap: 5px;
        }

        .city-option {
            padding: 8px 16px;
            border-radius: 20px;
            background: transparent;
            border: none;
            color: #424242;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.5;
        }

        .city-option.active {
            background: rgba(66, 66, 66, 0.8);
            color: white;
            opacity: 1;
        }

        .city-option:hover {
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- City selector -->
    <div class="city-selector">
        <button class="city-option active" onclick="switchCity('seattle')" id="seattle-btn">SEATTLE</button>
        <button class="city-option" onclick="switchCity('nyc')" id="nyc-btn">NEW YORK</button>
        <button class="city-option" onclick="switchCity('chicago')" id="chicago-btn">CHICAGO</button>
        <button class="city-option" onclick="switchCity('sfo')" id="sfo-btn">SAN FRANCISCO</button>
    </div>
    
    <!-- City name title -->
    <div class="city-title" id="cityTitle" onclick="toggleCity()">SEATTLE</div>
    
    <!-- City subtitle -->
    <div class="city-subtitle" id="citySubtitle">FOOD ESTABLISHMENT INSPECTION</div>
    
    <button class="toggle-btn" id="toggleBtn" onclick="togglePanel()">
     SETTINGS
    </button>

    <div class="side-panel" id="sidePanel">
        <div class="panel-header">
            <div class="panel-title">Food Establishment Inspection Data</div>
            <button class="close-btn" onclick="togglePanel()">Ã—</button>
        </div>
        
        <div class="panel-content">
            <div class="controls">
                <div class="control-group">
                    <label>Inspection Type</label>
                    <select id="inspectionTypeFilter">
                        <option value="all">All Types</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Grade</label>
                    <select id="gradeFilter">
                        <option value="all">All Grades</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Risk Level</label>
                    <select id="riskFilter">
                        <option value="all">All Risk Levels</option>
                        <option value="high">High Risk (15+ points)</option>
                        <option value="medium">Medium Risk (5-14 points)</option>
                        <option value="low">Low Risk (0-4 points)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Start Date</label>
                    <input type="date" id="startDate">
                </div>
                <div class="control-group">
                    <label>End Date</label>
                    <input type="date" id="endDate">
                </div>
                <div class="control-group">
                    <button id="refreshBtn" onclick="refreshData()">
                        ðŸ”„ Refresh Data
                    </button>
                </div>
            </div>

            <div class="status-info" id="statusInfo" style="display: none;">
                <div id="lastUpdate"></div>
            </div>
            
            <div class="legend">
                <h3>Grade/Result Legend</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2e7d32;"></div>
                    <span>Excellent/Pass</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #689f38;"></div>
                    <span>Good/Conditional</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #fbc02d;"></div>
                    <span>Satisfactory</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f57c00;"></div>
                    <span>Needs Improvement</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #d32f2f;"></div>
                    <span>Poor/Fail/Closure</span>
                </div>
            </div>

            <div class="legend">
                <h3>Risk Classification</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #d32f2f;"></div>
                    <span class="risk-high">High Risk (15+ points or Risk 1)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f57c00;"></div>
                    <span class="risk-medium">Medium Risk (5-14 points or Risk 2)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #388e3c;"></div>
                    <span class="risk-low">Low Risk (0-4 points or Risk 3)</span>
                </div>
            </div>

            <div class="stats" id="stats">
                <h3>Map Statistics</h3>
                <div id="statsContent">
                    <p style="color: #666; font-style: italic;">Filter the map to view inspection statistics</p>
                </div>
            </div>
        </div>
    </div>

    <div class="error" id="error" style="display: none;"></div>

    <!-- Combined progress container for data loading and marker plotting -->
    <div class="progress-container" id="progressContainer">
        <div class="progress-text" id="progressText">Loading restaurants...</div>
        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="progress-stats" id="progressStats">0 / 0 markers loaded</div>
    </div>

    <script>
        let map;
        let inspectionData = [];
        let individualMarkers = [];
        let lastRefreshTime = null;
        let autoRefreshInterval = null;
        let isLoadingIndividualMarkers = false;
        let progressContainer = null;
        let progressBar = null;
        let progressText = null;
        let progressStats = null;
        let markerClusterGroup = null;
        let spatialIndex = null;
        let currentZoomLevel = 11;
        let maxMarkersPerLoad = 2000;
        let currentCity = 'seattle';
        let isLoadingData = false;
        let loadingAbortController = null;
        let currentFilters = {
            inspectionType: 'all',
            grade: 'all',
            risk: 'all',
            startDate: null,
            endDate: null
        };

        // City configurations
        const cityConfigs = {
            seattle: {
                name: 'SEATTLE',
                center: [47.6105, -122.3193],
                zoom: 14,
                csvFile: 'seattle-Food_Establishment_Inspection_Data.csv',
                apiUrl: 'https://data.kingcounty.gov/resource/f29f-zza5.json',
                maxApiLimit: 10000, // King County API limit
                dataMapping: {
                    name: 'Name',
                    inspectionDate: 'Inspection Date',
                    address: 'Address',
                    zipCode: 'Zip Code',
                    latitude: 'Latitude',
                    longitude: 'Longitude',
                    inspectionType: 'Inspection Type',
                    inspectionScore: 'Inspection Score',
                    inspectionResult: 'Inspection Result',
                    violationType: 'Violation Type',
                    violationPoints: 'Violation Points',
                    grade: 'Grade',
                    businessId: 'Business_ID'
                },
                apiMapping: {
                    name: 'name',
                    inspectionDate: 'inspection_date',
                    address: 'address',
                    zipCode: 'zipcode',
                    latitude: 'latitude',
                    longitude: 'longitude',
                    inspectionType: 'inspection_type',
                    inspectionScore: 'inspection_score',
                    inspectionResult: 'inspection_result',
                    violationType: 'violation_type',
                    violationPoints: 'violation_points',
                    grade: 'grade',
                    businessId: 'business_id'
                }
            },
            nyc: {
                name: 'NEW YORK',
                center: [40.7128, -74.0060],
                zoom: 14,
                csvFile: 'nyc-DOHMH_New_York_City_Restaurant_Inspection_Results_20250726.csv',
                apiUrl: 'https://data.cityofnewyork.us/resource/43nn-pn8j.json',
                maxApiLimit: 50000, // SODA 2.0 API limit
                dataMapping: {
                    name: 'DBA',
                    inspectionDate: 'INSPECTION DATE',
                    address: 'BUILDING',
                    zipCode: 'ZIPCODE',
                    latitude: 'Latitude',
                    longitude: 'Longitude',
                    inspectionType: 'INSPECTION TYPE',
                    inspectionScore: 'SCORE',
                    inspectionResult: 'GRADE',
                    violationType: 'VIOLATION CODE',
                    violationPoints: 'SCORE',
                    grade: 'GRADE',
                    businessId: 'CAMIS'
                },
                apiMapping: {
                    name: 'dba',
                    inspectionDate: 'inspection_date',
                    address: 'building',
                    zipCode: 'zipcode',
                    latitude: 'latitude',
                    longitude: 'longitude',
                    inspectionType: 'inspection_type',
                    inspectionScore: 'score',
                    inspectionResult: 'grade',
                    violationType: 'violation_code',
                    violationPoints: 'score',
                    grade: 'grade',
                    businessId: 'camis'
                }
            },
            chicago: {
                name: 'CHICAGO',
                center: [41.8781, -87.6298],
                zoom: 14,
                csvFile: 'chicago-Food_Inspections_20250731.csv',
                apiUrl: 'https://data.cityofchicago.org/api/v3/views/4ijn-s7e5/query.json',
                maxApiLimit: 50000, // Chicago API limit
                dataMapping: {
                    name: 'DBA Name',
                    inspectionDate: 'Inspection Date',
                    address: 'Address',
                    zipCode: '', // No zip code in Chicago data
                    latitude: 'Latitude',
                    longitude: 'Longitude',
                    inspectionType: 'Inspection Type',
                    inspectionScore: '', // No numeric score, using Results instead
                    inspectionResult: 'Results',
                    violationType: 'Violations',
                    violationPoints: '', // Need to calculate from violations
                    grade: 'Results', // Using Results as grade equivalent
                    businessId: 'License #',
                    risk: 'Risk' // Chicago has risk classification
                },
                apiMapping: {
                    name: 'dba_name',
                    inspectionDate: 'inspection_date',
                    address: 'address',
                    zipCode: '',
                    latitude: 'latitude',
                    longitude: 'longitude',
                    inspectionType: 'inspection_type',
                    inspectionScore: '',
                    inspectionResult: 'results',
                    violationType: 'violations',
                    violationPoints: '',
                    grade: 'results',
                    businessId: 'license_',
                    risk: 'risk'
                }
            },
            sfo: {
                name: 'SAN FRANCISCO',
                center: [37.7749, -122.4194],
                zoom: 14,
                csvFile: 'sfo-Health_Inspection_Scores__2024-Present__20250731.csv',
                apiUrl: 'https://data.sfgov.org/resource/tvy3-wexg.json',
                maxApiLimit: 50000, // SF API limit
                dataMapping: {
                    name: 'dba',
                    inspectionDate: 'inspection_date',
                    address: 'street_address',
                    zipCode: '', // No zip code in SF data
                    latitude: 'latitude',
                    longitude: 'longitude',
                    inspectionType: 'inspection_type',
                    inspectionScore: 'violation_count',
                    inspectionResult: 'facility_rating_status',
                    violationType: 'violation_codes',
                    violationPoints: 'violation_count', // Using violation count as points
                    grade: 'facility_rating_status',
                    businessId: 'permit_number'
                },
                apiMapping: {
                    name: 'dba',
                    inspectionDate: 'inspection_date',
                    address: 'street_address',
                    zipCode: '',
                    latitude: 'latitude',
                    longitude: 'longitude',
                    inspectionType: 'inspection_type',
                    inspectionScore: 'violation_count',
                    inspectionResult: 'facility_rating_status',
                    violationType: 'violation_codes',
                    violationPoints: 'violation_count',
                    grade: 'facility_rating_status',
                    businessId: 'permit_number'
                }
            }
        };

        // Calculate letter spacing to match title width
        function calculateLetterSpacing(titleText, subtitleText) {
            // City-specific character width estimates
            let titleCharWidth;
            if (titleText === 'SEATTLE') {
                titleCharWidth = 42.5;
            } else if (titleText === 'NEW YORK') {
                titleCharWidth = 47;
            } else if (titleText === 'CHICAGO') {
                titleCharWidth = 45;
            } else if (titleText === 'SAN FRANCISCO') {
                titleCharWidth = 43;
            } else {
                titleCharWidth = 42.5; // default fallback
            }
            
            const subtitleCharWidth = 8; // 12px font size characters are about 8px wide
            
            const titleWidth = titleText.length * titleCharWidth;
            const subtitleWidth = subtitleText.length * subtitleCharWidth;
            
            // Calculate additional spacing needed to match title width
            const extraWidth = titleWidth - subtitleWidth;
            const spacingPerGap = extraWidth / (subtitleText.length - 1);
            
            // Convert to em units for letter-spacing
            const letterSpacing = spacingPerGap / 12; // Based on 12px subtitle font size
            
            return Math.max(0, letterSpacing);
        }

        // Update subtitle letter spacing
        function updateSubtitleSpacing() {
            const titleText = cityConfigs[currentCity].name;
            const subtitleText = 'FOOD ESTABLISHMENT INSPECTION';
            const spacing = calculateLetterSpacing(titleText, subtitleText);
            document.getElementById('citySubtitle').style.letterSpacing = spacing + 'em';
        }

        // Switch city function
        function switchCity(city) {
            if (city === currentCity) return;
            
            // Abort any ongoing data loading
            if (loadingAbortController) {
                loadingAbortController.abort();
                console.log(`Aborted loading for ${currentCity}`);
            }
            
            // Stop any ongoing marker loading
            isLoadingIndividualMarkers = false;
            
            // Hide any progress indicators
            hideProgress();
            
            const oldCity = currentCity;
            currentCity = city;
            
            // Update UI immediately
            document.getElementById('cityTitle').textContent = cityConfigs[city].name;
            updateSubtitleSpacing();
            
            // Update city selector buttons
            document.getElementById('seattle-btn').classList.toggle('active', city === 'seattle');
            document.getElementById('nyc-btn').classList.toggle('active', city === 'nyc');
            document.getElementById('chicago-btn').classList.toggle('active', city === 'chicago');
            document.getElementById('sfo-btn').classList.toggle('active', city === 'sfo');
            
            // Fly to new city
            map.flyTo(cityConfigs[city].center, cityConfigs[city].zoom, {
                duration: 2,
                easeLinearity: 0.5
            });
            
            // Clear existing data and load new city data immediately
            clearAllMarkers();
            inspectionData = [];
            spatialIndex = null;
            
            // Load new city data immediately
            loadData().then(() => {
                // Load markers for the new city after data is loaded
                console.log(`Data loaded for ${city}, loading markers...`);
                setTimeout(() => {
                    loadIndividualMarkersInView();
                }, 200);
            }).catch(error => {
                console.error('Error loading data for new city:', error);
            });
        }

        // Toggle between cities (for clicking title)
        function toggleCity() {
            const cities = ['seattle', 'nyc', 'chicago', 'sfo'];
            const currentIndex = cities.indexOf(currentCity);
            const nextIndex = (currentIndex + 1) % cities.length;
            const nextCity = cities[nextIndex];
            switchCity(nextCity);
        }

        // Toggle side panel
        function togglePanel() {
            const panel = document.getElementById('sidePanel');
            const toggleBtn = document.getElementById('toggleBtn');
            
            panel.classList.toggle('open');
            
            if (panel.classList.contains('open')) {
               // toggleBtn.textContent = 'ðŸ“Š Hide Panel';
            } else {
                toggleBtn.textContent = 'SETTINGS';
            }
        }

        // Refresh data manually
        async function refreshData() {
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'ðŸ”„ Checking for updates...';
            
            try {
                await loadData();
                lastRefreshTime = new Date();
                updateLastRefreshDisplay();
                
            } catch (error) {
                console.error('Error refreshing data:', error);
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error refreshing data: ${error.message}`;
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'ðŸ”„ Refresh Data';
            }
        }

        // Update last refresh time display
        function updateLastRefreshDisplay() {
            if (lastRefreshTime) {
                const timeString = lastRefreshTime.toLocaleTimeString();
                const dateString = lastRefreshTime.toLocaleDateString();
                document.getElementById('lastUpdate').textContent = `Last Updated: ${dateString} at ${timeString}`;
                document.getElementById('statusInfo').style.display = 'block';
            }
        }

        // Risk classification function
        function classifyRisk(violationPoints) {
            const points = parseInt(violationPoints) || 0;
            if (points >= 15) return 'high';
            if (points >= 5) return 'medium';
            return 'low';
        }

        // Grade color mapping
        function getGradeColor(grade) {
            const gradeColors = {
                // NYC and standard grades
                'A': '#2e7d32',  // Green - Excellent
                'B': '#689f38',  // Light Green - Good
                'C': '#fbc02d',  // Yellow - Satisfactory
                'P': '#f57c00',  // Orange - Pending
                'Z': '#d32f2f',  // Red - Grade Pending
                
                // Seattle numeric grades
                '1': '#2e7d32',  // Green - Seattle excellent
                '2': '#689f38',  // Light Green - Seattle good
                '3': '#fbc02d',  // Yellow - Seattle satisfactory
                '4': '#f57c00',  // Orange - Seattle needs improvement
                '5': '#d32f2f',  // Red - Seattle poor
                
                // Chicago results
                'Pass': '#2e7d32',           // Green
                'Pass w/ Conditions': '#689f38',  // Light Green
                'Fail': '#d32f2f',           // Red
                'Not Ready': '#9e9e9e',      // Gray
                'No Entry': '#9e9e9e',       // Gray
                'Out of Business': '#616161', // Dark Gray
                
                // San Francisco facility rating status
                'Pass': '#2e7d32',           // Green
                'Conditional Pass': '#689f38', // Light Green
                'Closure': '#d32f2f',        // Red
                'Reinspection': '#f57c00',   // Orange
                'Suspend': '#d32f2f'         // Red
            };
            return gradeColors[grade] || '#9e9e9e';
        }

        // Risk color mapping
        function getRiskColor(riskLevel) {
            const riskColors = {
                'high': '#d32f2f',
                'medium': '#f57c00',
                'low': '#388e3c'
            };
            return riskColors[riskLevel] || '#9e9e9e';
        }

        // Risk border color mapping (darker versions)
        function getRiskBorderColor(riskLevel) {
            const riskBorderColors = {
                'high': '#b71c1c',
                'medium': '#e65100',
                'low': '#1b5e20'
            };
            return riskBorderColors[riskLevel] || '#616161';
        }

        // Initialize map
        function initializeMap() {
            map = L.map('map', {
                minZoom: 12,
                maxZoom: 18,
                zoomControl: false
            }).setView(cityConfigs[currentCity].center, cityConfigs[currentCity].zoom);
            
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: 'Â© OpenStreetMap contributors, Â© CARTO'
            }).addTo(map);

            // Initialize progress bar elements
            progressContainer = document.getElementById('progressContainer');
            progressBar = document.getElementById('progressBar');
            progressText = document.getElementById('progressText');
            progressStats = document.getElementById('progressStats');

            // Track zoom level for adaptive loading
            currentZoomLevel = map.getZoom();
            map.on('zoomend', function() {
                currentZoomLevel = map.getZoom();
                maxMarkersPerLoad = getMaxMarkersForZoom(currentZoomLevel);
            });

            // Add moveend event with debouncing for performance
            let moveTimeout;
            map.on('moveend', function() {
                clearTimeout(moveTimeout);
                moveTimeout = setTimeout(() => {
                    loadIndividualMarkersInView();
                }, 300);
            });
        }

        // Load and parse data
        async function loadData() {
            // Prevent multiple simultaneous loads and set up abort controller
            if (isLoadingData) {
                if (loadingAbortController) {
                    loadingAbortController.abort();
                }
            }
            
            isLoadingData = true;
            loadingAbortController = new AbortController();
            const signal = loadingAbortController.signal;
            
            try {
                // Check if loading was aborted before starting
                if (signal.aborted) {
                    console.log('Data loading aborted before starting');
                    return;
                }
                
                showDataProgress(`Loading ${cityConfigs[currentCity].name} data...`);
                
                inspectionData = await loadFromCSV(currentCity, signal);
                
                // Check if loading was aborted after CSV load
                if (signal.aborted) {
                    console.log('Data loading aborted after CSV load');
                    return;
                }
                
                console.log(`Loaded ${inspectionData.length} inspection records for ${currentCity}`);
                
                // Populate filter options and create initial map
                populateFilters();
                
                hideProgress();
                console.log('Data loaded successfully');
                
                // Load markers for the initial view immediately
                console.log('Starting initial marker loading...');
                setTimeout(() => {
                    loadIndividualMarkersInView();
                }, 100);
                
            } catch (error) {
                if (error.name === 'AbortError' || error.message === 'AbortError') {
                    console.log('Data loading was aborted');
                    return;
                }
                
                console.error('Error loading data:', error);
                hideProgress();
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading inspection data: ${error.message}`;
            } finally {
                isLoadingData = false;
                loadingAbortController = null;
            }
        }

        // Load supplemental data from API with pagination
        async function loadSupplementalAPIData(city, signal = null) {
            const config = cityConfigs[city];
            if (!config.apiUrl) {
                console.log(`No API configured for ${city}`);
                return [];
            }
            
            console.log(`Loading supplemental data from API for ${city}`);
            const currentYear = new Date().getFullYear();
            const allApiData = [];
            let offset = 0;
            const limit = 1000; // Batch size per request
            let hasMoreData = true;
            
            try {
                while (hasMoreData && allApiData.length < config.maxApiLimit) {
                    // Check if loading was aborted
                    if (signal && signal.aborted) {
                        throw new Error('Loading aborted');
                    }
                    
                    // Build API URL with pagination and date filter
                    const apiUrl = new URL(config.apiUrl);
                    apiUrl.searchParams.set('$limit', limit.toString());
                    apiUrl.searchParams.set('$offset', offset.toString());
                    
                    // Filter for current year data
                    if (city === 'seattle') {
                        apiUrl.searchParams.set('$where', `date_extract_y(inspection_date) = ${currentYear}`);
                    } else if (city === 'nyc') {
                        apiUrl.searchParams.set('$where', `date_extract_y(inspection_date) = ${currentYear}`);
                    }
                    
                    console.log(`Fetching API data: offset=${offset}, limit=${limit}`);
                    
                    const response = await fetch(apiUrl.toString(), { signal });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                    }
                    
                    const batchData = await response.json();
                    
                    // Check if we got data
                    if (!batchData || batchData.length === 0) {
                        hasMoreData = false;
                        break;
                    }
                    
                    allApiData.push(...batchData);
                    offset += limit;
                    
                    // If we got less than the limit, we've reached the end
                    if (batchData.length < limit) {
                        hasMoreData = false;
                    }
                    
                    console.log(`API batch loaded: ${batchData.length} records, total: ${allApiData.length}`);
                    
                    // Small delay to prevent overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                console.log(`API data loading complete: ${allApiData.length} total records from ${city} API`);
                
                // Process API data to match our internal format
                const processedApiData = allApiData.map(d => {
                    const mapping = config.apiMapping;
                    
                    // Parse date
                    let inspectionDate;
                    const dateStr = d[mapping.inspectionDate];
                    if (dateStr) {
                        inspectionDate = new Date(dateStr);
                        if (isNaN(inspectionDate.getTime())) {
                            inspectionDate = new Date();
                        }
                    } else {
                        inspectionDate = new Date();
                    }
                    
                    const lat = parseFloat(d[mapping.latitude]);
                    const lng = parseFloat(d[mapping.longitude]);
                    
                    return {
                        name: d[mapping.name] || '',
                        inspectionDate: inspectionDate,
                        address: d[mapping.address] || '',
                        zipCode: d[mapping.zipCode] || '',
                        latitude: lat,
                        longitude: lng,
                        inspectionType: d[mapping.inspectionType] || '',
                        inspectionScore: parseInt(d[mapping.inspectionScore]) || 0,
                        inspectionResult: d[mapping.inspectionResult] || '',
                        violationType: d[mapping.violationType] || '',
                        violationPoints: parseInt(d[mapping.violationPoints]) || 0,
                        grade: d[mapping.grade] || '',
                        businessId: d[mapping.businessId] || '',
                        riskLevel: classifyRisk(d[mapping.violationPoints]),
                        source: 'api' // Track data source
                    };
                }).filter(d => {
                    // Filter for valid records with coordinates
                    const hasValidCoords = d.latitude && d.longitude && d.zipCode && 
                                         !isNaN(d.latitude) && !isNaN(d.longitude);
                    const isCurrentYear = d.inspectionDate.getFullYear() === currentYear;
                    return hasValidCoords && isCurrentYear;
                });
                
                console.log(`Processed API data: ${processedApiData.length} valid records`);
                return processedApiData;
                
            } catch (error) {
                if (error.message === 'Loading aborted') {
                    console.log(`API loading aborted for ${city}`);
                    throw new Error('AbortError');
                }
                console.error(`Error loading API data for ${city}:`, error);
                // Return empty array on error - CSV data will still be available
                return [];
            }
        }

        // Helper function to get value from object with fallback column names
        function getValueWithFallback(data, primaryKey, fallbackKeys = []) {
            if (data[primaryKey] !== undefined) {
                return data[primaryKey];
            }
            
            for (const fallback of fallbackKeys) {
                if (data[fallback] !== undefined) {
                    console.log(`Using fallback column '${fallback}' instead of '${primaryKey}'`);
                    return data[fallback];
                }
            }
            
            return '';
        }

        // Load hybrid data from CSV and API
        async function loadFromCSV(city, signal = null) {
            const config = cityConfigs[city];
            console.log(`Loading hybrid data for ${city} from CSV + API`);
            
            try {
                // Check if aborted before starting
                if (signal && signal.aborted) {
                    throw new Error('Loading aborted');
                }
                
                // Load CSV data (main source)
                console.log(`Step 1: Loading CSV data from ${config.csvFile}`);
                const csvData = await d3.csv(config.csvFile);
                
                // Check if aborted after CSV load
                if (signal && signal.aborted) {
                    throw new Error('Loading aborted');
                }
                
                console.log(`Raw CSV data loaded: ${csvData.length} records`);
                updateProgress(1, 4, `Processing ${csvData.length} CSV records...`, 'data');
                
                // Get current year for filtering
                const currentYear = new Date().getFullYear();
                console.log(`Filtering data for current year: ${currentYear}`);
                
                // Process CSV data
                const processedCsvData = csvData.map(d => {
                    // Handle date parsing for different formats
                    let inspectionDate;
                    const dateStr = getValueWithFallback(d, config.dataMapping.inspectionDate, ['INSPECTION_DATE', 'InspectionDate', 'inspection_date']);
                    if (dateStr) {
                        // Try different date formats
                        inspectionDate = new Date(dateStr);
                        if (isNaN(inspectionDate.getTime())) {
                            // Try MM/DD/YYYY format
                            const parts = dateStr.split('/');
                            if (parts.length === 3) {
                                inspectionDate = new Date(parts[2], parts[0] - 1, parts[1]);
                            }
                        }
                    }

                    // Get latitude and longitude with fallbacks
                    const lat = parseFloat(getValueWithFallback(d, config.dataMapping.latitude, ['LAT', 'lat', 'LATITUDE']));
                    const lng = parseFloat(getValueWithFallback(d, config.dataMapping.longitude, ['LON', 'lng', 'LONGITUDE', 'lon']));

                    // Handle city-specific data processing
                    let violationPoints = 0;
                    let riskLevel = 'low';
                    
                    if (city === 'chicago') {
                        // Chicago has Risk column and violation text, calculate points from violations
                        const riskText = getValueWithFallback(d, config.dataMapping.risk, []) || '';
                        const violationText = getValueWithFallback(d, config.dataMapping.violationType, []) || '';
                        
                        // Extract risk level from Chicago risk text
                        if (riskText.includes('Risk 1') || riskText.includes('High')) {
                            riskLevel = 'high';
                            violationPoints = 20; // High risk default
                        } else if (riskText.includes('Risk 2') || riskText.includes('Medium')) {
                            riskLevel = 'medium';
                            violationPoints = 10; // Medium risk default
                        } else {
                            riskLevel = 'low';
                            violationPoints = 2; // Low risk default
                        }
                        
                        // Adjust points based on inspection result
                        const result = getValueWithFallback(d, config.dataMapping.inspectionResult, []) || '';
                        if (result === 'Fail') {
                            violationPoints += 10;
                        } else if (result === 'Pass w/ Conditions') {
                            violationPoints += 5;
                        }
                        
                    } else if (city === 'sfo') {
                        // San Francisco uses violation_count
                        violationPoints = parseInt(getValueWithFallback(d, config.dataMapping.violationPoints, [])) || 0;
                        
                        // Classify based on violation count for SF
                        if (violationPoints >= 10) {
                            riskLevel = 'high';
                        } else if (violationPoints >= 3) {
                            riskLevel = 'medium';
                        } else {
                            riskLevel = 'low';
                        }
                        
                    } else {
                        // Seattle and NYC use standard violation points
                        violationPoints = parseInt(getValueWithFallback(d, config.dataMapping.violationPoints, ['POINTS', 'points', 'score', 'Score'])) || 0;
                        riskLevel = classifyRisk(violationPoints);
                    }

                    const processed = {
                        name: getValueWithFallback(d, config.dataMapping.name, ['BUSINESS_NAME', 'BusinessName', 'NAME']) || '',
                        inspectionDate: inspectionDate || new Date(),
                        address: getValueWithFallback(d, config.dataMapping.address, ['ADDRESS', 'STREET', 'Street']) || '',
                        zipCode: getValueWithFallback(d, config.dataMapping.zipCode, ['ZIP', 'zip', 'ZIP_CODE']) || 'N/A',
                        latitude: lat,
                        longitude: lng,
                        inspectionType: getValueWithFallback(d, config.dataMapping.inspectionType, ['TYPE', 'type']) || '',
                        inspectionScore: parseInt(getValueWithFallback(d, config.dataMapping.inspectionScore, ['score', 'Score'])) || 0,
                        inspectionResult: getValueWithFallback(d, config.dataMapping.inspectionResult, ['RESULT', 'result']) || '',
                        violationType: getValueWithFallback(d, config.dataMapping.violationType, ['VIOLATION', 'violation']) || '',
                        violationPoints: violationPoints,
                        grade: getValueWithFallback(d, config.dataMapping.grade, ['grade', 'Grade']) || '',
                        businessId: getValueWithFallback(d, config.dataMapping.businessId, ['ID', 'id', 'business_id']) || '',
                        riskLevel: riskLevel,
                        source: 'csv' // Track data source
                    };
                    
                    return processed;
                }).filter(d => {
                    // Filter for valid records with coordinates
                    const hasValidCoords = d.latitude && d.longitude && !isNaN(d.latitude) && !isNaN(d.longitude);
                    
                    // For cities without zip codes (Chicago, SF), don't require zipCode
                    const hasLocation = city === 'chicago' || city === 'sfo' ? hasValidCoords : (hasValidCoords && d.zipCode);
                    
                    // Filter for current year only
                    const isCurrentYear = d.inspectionDate && d.inspectionDate.getFullYear() === currentYear;
                    
                    return hasLocation && isCurrentYear;
                });

                console.log(`Processed CSV data: ${processedCsvData.length} valid records for ${currentYear}`);
                
                // Check if aborted before API load
                if (signal && signal.aborted) {
                    throw new Error('Loading aborted');
                }
                
                // Step 2: Load supplemental API data
                console.log(`Step 2: Loading supplemental API data`);
                updateProgress(2, 4, `Loading supplemental API data...`, 'data');
                let apiData = [];
                try {
                    apiData = await loadSupplementalAPIData(city, signal);
                } catch (error) {
                    if (error.message === 'AbortError') {
                        throw new Error('Loading aborted');
                    }
                    console.warn(`API data loading failed, continuing with CSV only:`, error.message);
                    apiData = [];
                }
                
                // Check if aborted after API load
                if (signal && signal.aborted) {
                    throw new Error('Loading aborted');
                }
                
                // Step 3: Merge and deduplicate data
                console.log(`Step 3: Merging CSV (${processedCsvData.length}) and API (${apiData.length}) data`);
                updateProgress(3, 4, `Merging ${processedCsvData.length + apiData.length} records...`, 'data');
                
                // Create a map for deduplication based on business ID and date
                const dataMap = new Map();
                
                // Add CSV data first (lower priority)
                processedCsvData.forEach(record => {
                    const key = `${record.businessId}-${record.inspectionDate.toDateString()}`;
                    dataMap.set(key, record);
                });
                
                // Add API data (higher priority - will overwrite CSV data for same business+date)
                let apiOverwrites = 0;
                apiData.forEach(record => {
                    const key = `${record.businessId}-${record.inspectionDate.toDateString()}`;
                    if (dataMap.has(key)) {
                        apiOverwrites++;
                    }
                    dataMap.set(key, record);
                });
                
                const mergedData = Array.from(dataMap.values());
                
                // Data source breakdown for debugging
                const csvCount = mergedData.filter(r => r.source === 'csv').length;
                const apiCount = mergedData.filter(r => r.source === 'api').length;
                console.log(`Final data breakdown - CSV: ${csvCount}, API: ${apiCount}`);
                console.log(`Data merged: ${mergedData.length} total records (${apiOverwrites} API overwrites)`);
                
                if (mergedData.length === 0) {
                    throw new Error(`No valid records found for ${city} in ${currentYear}. Data may be from a different year or have mapping issues.`);
                }
                
                // Create spatial index for fast queries
                console.log('Creating spatial index...');
                updateProgress(4, 4, `Creating spatial index for ${mergedData.length} records...`, 'data');
                spatialIndex = createSpatialIndex(mergedData);
                
                // Check if aborted after spatial index creation
                if (signal && signal.aborted) {
                    throw new Error('Loading aborted');
                }
                
                console.log(`Spatial index created with ${spatialIndex.size} grid cells`);
                console.log(`Hybrid data loading complete: ${processedCsvData.length} CSV + ${apiData.length} API = ${mergedData.length} total records`);
                
                return mergedData;
                
            } catch (error) {
                if (error.message === 'Loading aborted') {
                    console.log(`Hybrid data loading aborted for ${city}`);
                    throw new Error('AbortError');
                }
                console.error(`Error loading hybrid data for ${city}:`, error);
                throw error;
            }
        }

        // Clear all markers from the map
        function clearAllMarkers() {
            clearIndividualMarkers();
        }

        // Clear only individual markers
        function clearIndividualMarkers() {
            individualMarkers.forEach(marker => {
                map.removeLayer(marker);
            });
            individualMarkers = [];
        }

        // Show progress bar
        function showProgress(text = 'Loading restaurants...', type = 'markers') {
            progressContainer.style.display = 'block';
            progressText.textContent = text;
            progressBar.style.width = '0%';
            if (type === 'data') {
                progressStats.textContent = 'Preparing data...';
            } else {
                progressStats.textContent = '0 / 0 markers loaded';
            }
        }

        // Update progress bar
        function updateProgress(current, total, text = null, type = 'markers') {
            if (text) progressText.textContent = text;
            const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
            progressBar.style.width = percentage + '%';
            if (type === 'data') {
                progressStats.textContent = current > 0 && total > 0 ? `Processing ${current} of ${total} records` : 'Loading data...';
            } else {
                progressStats.textContent = `${current} / ${total} markers loaded`;
            }
        }

        // Show data loading progress
        function showDataProgress(text) {
            showProgress(text, 'data');
        }

        // Hide progress bar
        function hideProgress() {
            setTimeout(() => {
                progressContainer.style.display = 'none';
            }, 500);
        }

        // Get maximum markers to load based on zoom level
        function getMaxMarkersForZoom(zoom) {
            if (zoom >= 16) return 5000;
            if (zoom >= 14) return 6000;
            if (zoom >= 12) return 15000;
            if (zoom >= 10) return 15000;
            return 15000;
        }

        // Spatial indexing for faster bounds queries
        function createSpatialIndex(data) {
            const gridSize = 0.01;
            const index = new Map();
            
            data.forEach((inspection, idx) => {
                const gridX = Math.floor(inspection.latitude / gridSize);
                const gridY = Math.floor(inspection.longitude / gridSize);
                const key = `${gridX},${gridY}`;
                
                if (!index.has(key)) {
                    index.set(key, []);
                }
                index.get(key).push(inspection);
            });
            
            return index;
        }

        // Fast bounds query using spatial index
        function queryByBounds(bounds, maxResults = 1000) {
            if (!spatialIndex) return [];
            
            const results = [];
            const gridSize = 0.01;
            
            const minX = Math.floor(bounds.getSouth() / gridSize);
            const maxX = Math.ceil(bounds.getNorth() / gridSize);
            const minY = Math.floor(bounds.getWest() / gridSize);
            const maxY = Math.ceil(bounds.getEast() / gridSize);
            
            for (let x = minX; x <= maxX && results.length < maxResults; x++) {
                for (let y = minY; y <= maxY && results.length < maxResults; y++) {
                    const key = `${x},${y}`;
                    const gridData = spatialIndex.get(key);
                    
                    if (gridData) {
                        for (const inspection of gridData) {
                            if (results.length >= maxResults) break;
                            if (bounds.contains([inspection.latitude, inspection.longitude])) {
                                results.push(inspection);
                            }
                        }
                    }
                }
            }
            
            return results;
        }

        // Priority-based marker selection
        function prioritizeMarkers(markers, zoom) {
            return markers.sort((a, b) => {
                if (a.riskLevel !== b.riskLevel) {
                    const riskPriority = { 'high': 3, 'medium': 2, 'low': 1 };
                    return riskPriority[b.riskLevel] - riskPriority[a.riskLevel];
                }
                
                if (a.inspectionDate !== b.inspectionDate) {
                    return b.inspectionDate - a.inspectionDate;
                }
                
                return b.violationPoints - a.violationPoints;
            });
        }

        // Load individual markers for current map view
        async function loadIndividualMarkersInView() {
            if (isLoadingIndividualMarkers) return;
            
            // Check if map and data are ready
            if (!map || !inspectionData || inspectionData.length === 0) {
                console.log('Map or data not ready for marker loading');
                return;
            }
            
            // Create a unique identifier for this loading session
            const loadingSessionId = Date.now();
            const currentLoadingCity = currentCity;
            
            isLoadingIndividualMarkers = true;
            
            try {
                const startTime = performance.now();
                const bounds = map.getBounds();
                
                let filteredData;
                if (spatialIndex) {
                    const boundsData = queryByBounds(bounds, Number.MAX_SAFE_INTEGER);
                    filteredData = getFilteredData(boundsData);
                } else {
                    filteredData = getFilteredData().filter(inspection => {
                        return bounds.contains([inspection.latitude, inspection.longitude]);
                    });
                }

                // Check if city changed during data filtering
                if (currentCity !== currentLoadingCity) {
                    console.log(`City changed during marker loading (${currentLoadingCity} -> ${currentCity}), aborting`);
                    return;
                }

                filteredData = prioritizeMarkers(filteredData, currentZoomLevel);
                console.log(`Loading ALL ${filteredData.length} restaurants in current view`);

                const showProgressBar = filteredData.length > 100;
                
                if (showProgressBar) {
                    showProgress(`Loading ${Math.min(filteredData.length, maxMarkersPerLoad)} restaurants...`);
                }
                
                const removalStartTime = performance.now();
                individualMarkers = individualMarkers.filter(marker => {
                    const markerLatLng = marker.getLatLng();
                    if (!bounds.contains(markerLatLng)) {
                        map.removeLayer(marker);
                        return false;
                    }
                    return true;
                });
                console.log(`Marker removal took: ${performance.now() - removalStartTime}ms`);
                
                const existingCoords = new Set(individualMarkers.map(m => `${m.getLatLng().lat},${m.getLatLng().lng}`));
                
                const newMarkers = [];
                let processedCount = 0;
                const batchSize = 50;
                
                for (let i = 0; i < filteredData.length; i += batchSize) {
                    // Check if city changed during processing
                    if (currentCity !== currentLoadingCity) {
                        console.log(`City changed during marker processing, aborting`);
                        if (showProgressBar) hideProgress();
                        return;
                    }
                    
                    const batch = filteredData.slice(i, i + batchSize);
                    
                    for (const inspection of batch) {
                        const coordKey = `${inspection.latitude},${inspection.longitude}`;
                        if (!existingCoords.has(coordKey)) {
                            const marker = createSingleIndividualMarker(inspection);
                            newMarkers.push(marker);
                            processedCount++;
                        }
                    }
                    
                    if (showProgressBar) {
                        updateProgress(i + batch.length, filteredData.length);
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                // Final check before adding markers
                if (currentCity !== currentLoadingCity) {
                    console.log(`City changed before adding markers, cleaning up`);
                    newMarkers.forEach(marker => map.removeLayer(marker));
                    if (showProgressBar) hideProgress();
                    return;
                }
                
                individualMarkers.push(...newMarkers);
                
                if (showProgressBar) {
                    updateProgress(filteredData.length, filteredData.length, 
                        `${newMarkers.length} restaurants loaded!`);
                    hideProgress();
                }
                
                updateMapStats();
                
                const totalTime = performance.now() - startTime;
                console.log(`Total loading time: ${totalTime}ms for ${newMarkers.length} markers`);
                
            } finally {
                isLoadingIndividualMarkers = false;
            }
        }

        // Create a single individual marker
        function createSingleIndividualMarker(inspection) {
            const lat = inspection.latitude;
            const lng = inspection.longitude;
            
            const marker = L.circleMarker([lat, lng], {
                radius: 3,
                fillColor: getRiskColor(inspection.riskLevel),
                color: getRiskBorderColor(inspection.riskLevel),
                weight: 0.3, 
                opacity: 0.3,
                fillOpacity: 0.1 
            });

            marker.bindPopup(createIndividualPopupContent(inspection));
            marker.addTo(map);
            
            return marker;
        }

        // Populate filter dropdowns
        function populateFilters() {
            const inspectionTypes = [...new Set(inspectionData.map(d => d.inspectionType))].filter(Boolean);
            const grades = [...new Set(inspectionData.map(d => d.grade))].filter(Boolean).sort();

            const inspectionTypeSelect = document.getElementById('inspectionTypeFilter');
            inspectionTypeSelect.innerHTML = '<option value="all">All Types</option>';
            inspectionTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                inspectionTypeSelect.appendChild(option);
            });

            const gradeSelect = document.getElementById('gradeFilter');
            gradeSelect.innerHTML = '<option value="all">All Grades</option>';
            grades.forEach(grade => {
                const option = document.createElement('option');
                option.value = grade;
                option.textContent = `Grade ${grade}`;
                gradeSelect.appendChild(option);
            });

            setupFilterListeners();
        }

        // Create popup content for individual restaurant markers
        function createIndividualPopupContent(inspection) {
            const inspectionDate = inspection.inspectionDate.toLocaleDateString();
            const riskColor = getRiskColor(inspection.riskLevel);
            const gradeColor = inspection.grade ? getGradeColor(inspection.grade) : '#9e9e9e';
            const sourceIcon = inspection.source === 'api' ? 'ðŸ”´' : 'ðŸŸ¡';
            const sourceText = inspection.source === 'api' ? 'Live API' : 'CSV Data';
            
            return `
                <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 300px; margin: 0; padding: 0; background: transparent;">
                    <!-- Header with restaurant name -->
                    <div style="background: linear-gradient(135deg, #007cba, #005a87); color: white; padding: 15px; margin: 0; border-radius: 8px 8px 0 0;">
                        <h3 style="margin: 0; font-size: 16px; font-weight: bold; line-height: 1.3;">${inspection.name}</h3>
                        <p style="margin: 5px 0 0 0; opacity: 0.9; font-size: 12px;">ðŸ“ ${inspection.address}</p>
                        <p style="margin: 5px 0 0 0; opacity: 0.7; font-size: 10px;">${sourceIcon} ${sourceText}</p>
                    </div>
                    
                    <!-- Risk and Grade badges -->
                    <div style="display: flex; gap: 8px; margin: 0; padding: 15px; align-items: center; background: white;">
                        <div style="background: ${riskColor}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; text-transform: uppercase;">
                            ${inspection.riskLevel} Risk
                        </div>
                        ${inspection.grade ? `
                        <div style="background: ${gradeColor}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">
                            Grade ${inspection.grade}
                        </div>` : ''}
                    </div>
                    
                    <!-- Inspection details grid -->
                    <div style="display: grid; gap: 8px; margin: 0; padding: 0 15px 15px 15px; background: white;">
                        <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(0,0,0,0.1);">
                            <span style="color: #666; font-size: 12px; font-weight: 500;">ðŸ“… Inspection Date</span>
                            <span style="font-size: 12px; font-weight: bold;">${inspectionDate}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(0,0,0,0.1);">
                            <span style="color: #666; font-size: 12px; font-weight: 500;">ðŸ” Type</span>
                            <span style="font-size: 12px; font-weight: bold;">${inspection.inspectionType}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(0,0,0,0.1);">
                            <span style="color: #666; font-size: 12px; font-weight: 500;">âš ï¸ Violation Points</span>
                            <span style="font-size: 12px; font-weight: bold; color: ${riskColor};">${inspection.violationPoints}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 6px 0;">
                            <span style="color: #666; font-size: 12px; font-weight: 500;">ðŸ“‹ Result</span>
                            <span style="font-size: 12px; font-weight: bold;">${inspection.inspectionResult}</span>
                        </div>
                    </div>
                    
                    <!-- Footer with additional info -->
                    <div style="background: #f8f9fa; padding: 8px 15px; margin: 0; border-radius: 0 0 8px 8px; text-align: center;">
                        <p style="margin: 0; font-size: 10px; color: #666;">Business ID: ${inspection.businessId || 'N/A'}</p>
                    </div>
                </div>
            `;
        }

        // Get filtered data based on current filters
        function getFilteredData(dataToFilter = null) {
            const dataSource = dataToFilter || inspectionData;
            
            if (currentFilters.inspectionType === 'all' && 
                currentFilters.grade === 'all' && 
                currentFilters.risk === 'all' && 
                !currentFilters.startDate && 
                !currentFilters.endDate) {
                return dataSource;
            }
            
            return dataSource.filter(inspection => {
                if (currentFilters.inspectionType !== 'all' && inspection.inspectionType !== currentFilters.inspectionType) return false;
                if (currentFilters.grade !== 'all' && inspection.grade !== currentFilters.grade) return false;
                if (currentFilters.risk !== 'all' && inspection.riskLevel !== currentFilters.risk) return false;
                if (currentFilters.startDate && inspection.inspectionDate < currentFilters.startDate) return false;
                if (currentFilters.endDate && inspection.inspectionDate > currentFilters.endDate) return false;
                return true;
            });
        }

        // Show general map statistics
        function updateMapStats() {
            const statsContent = document.getElementById('statsContent');
            const filteredData = getFilteredData();
            
            if (filteredData.length === 0) {
                statsContent.innerHTML = '<p style="color: #666; font-style: italic;">No data matches current filters</p>';
                return;
            }

            const riskCounts = {
                high: filteredData.filter(d => d.riskLevel === 'high').length,
                medium: filteredData.filter(d => d.riskLevel === 'medium').length,
                low: filteredData.filter(d => d.riskLevel === 'low').length
            };

            // Data source breakdown
            const csvCount = filteredData.filter(d => d.source === 'csv').length;
            const apiCount = filteredData.filter(d => d.source === 'api').length;
            const csvPercent = Math.round(csvCount/filteredData.length*100);
            const apiPercent = Math.round(apiCount/filteredData.length*100);

            const gradeDistribution = {};
            filteredData.forEach(d => {
                if (d.grade) {
                    gradeDistribution[d.grade] = (gradeDistribution[d.grade] || 0) + 1;
                }
            });

            const gradeDistributionHtml = Object.entries(gradeDistribution)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([grade, count]) => 
                    `<div class="stat-item">
                        <span class="stat-label">Grade ${grade}:</span>
                        <span>${count} (${Math.round(count/filteredData.length*100)}%)</span>
                    </div>`
                ).join('');

            statsContent.innerHTML = `
                <div class="stat-item">
                    <span class="stat-label">Total Inspections:</span>
                    <span>${filteredData.length}</span>
                </div>
                
                <div class="stat-item">
                    <span class="stat-label">Restaurants Visible:</span>
                    <span>${individualMarkers.length}</span>
                </div>
                
                <h5 style="margin: 20px 0 10px 0;">Data Sources:</h5>
                <div class="stat-item">
                    <span class="stat-label">ðŸŸ¡ CSV Data:</span>
                    <span>${csvCount} (${csvPercent}%)</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ðŸ”´ API Data:</span>
                    <span>${apiCount} (${apiPercent}%)</span>
                </div>
                
                <h5 style="margin: 20px 0 10px 0;">Risk Distribution:</h5>
                <div class="stat-item">
                    <span class="stat-label risk-high">High Risk:</span>
                    <span>${riskCounts.high}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label risk-medium">Medium Risk:</span>
                    <span>${riskCounts.medium}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label risk-low">Low Risk:</span>
                    <span>${riskCounts.low}</span>
                </div>
                
                ${gradeDistributionHtml ? `<h5 style="margin: 20px 0 10px 0;">Grade Distribution:</h5>${gradeDistributionHtml}` : ''}
            `;
        }

        // Set up filter event listeners
        function setupFilterListeners() {
            document.getElementById('inspectionTypeFilter').addEventListener('change', applyFilters);
            document.getElementById('gradeFilter').addEventListener('change', applyFilters);
            document.getElementById('riskFilter').addEventListener('change', applyFilters);
            document.getElementById('startDate').addEventListener('change', applyFilters);
            document.getElementById('endDate').addEventListener('change', applyFilters);
        }

        // Apply filters to the map
        function applyFilters() {
            currentFilters = {
                inspectionType: document.getElementById('inspectionTypeFilter').value,
                grade: document.getElementById('gradeFilter').value,
                risk: document.getElementById('riskFilter').value,
                startDate: document.getElementById('startDate').value ? new Date(document.getElementById('startDate').value) : null,
                endDate: document.getElementById('endDate').value ? new Date(document.getElementById('endDate').value) : null
            };

            showProgress('Applying filters...');
            clearAllMarkers();
            
            setTimeout(() => {
                loadIndividualMarkersInView();
            }, 100);
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeMap();
            updateSubtitleSpacing(); // Set initial spacing
            
            loadData().then(() => {
                lastRefreshTime = new Date();
                updateLastRefreshDisplay();
                
                // Ensure markers are loaded after data is ready
                console.log('Data initialization complete, loading markers...');
                setTimeout(() => {
                    loadIndividualMarkersInView();
                }, 200);
                
                console.log('Application initialized successfully. Multi-city restaurant map loaded.');
            }).catch(error => {
                console.error('Failed to initialize application:', error);
            });
        });
    </script>
</body>
</html>
